namespace: flod
operation:
  name: pyth2
  inputs:
    - job_id:
        required: true
    - tool_region:
        required: true
    - operation:
        required: true
    - sse_config:
        required: true
    - targets:
        required: true
    - action:
        required: true
  python_action:
    use_jython: false
    script: "import ast\r\nimport json\r\nimport time\r\nimport re\r\nfrom sseapiclient.tornado import SyncClient\r\nfrom sseapiclient.exc import RPCError\r\nfrom datetime import datetime\r\n\r\n\r\ndef execute(job_id, tool_region, operation, sse_config, targets, action):\r\n    job_data_ready_flg = False\r\n    jobData = ''\r\n    sseStatus = None\r\n    success = False\r\n    stderr = ''\r\n    serverStatus = []\r\n    resultList = []\r\n    flg = 0\r\n    overallStatus = 'unknown error'\r\n\r\n    try:\r\n        targets = targets.split(',')\r\n        targets = [x.replace(' ','') for x in targets]\r\n        url = ast.literal_eval(sse_config)[tool_region]['url']\r\n        username = ast.literal_eval(sse_config)[tool_region]['username']\r\n        password = ast.literal_eval(sse_config)[tool_region]['password']\r\n\r\n        client, sseStatus, stderr = getClient(url, username, password)\r\n\r\n        if not sseStatus:\r\n            time.sleep(30)\r\n            client, sseStatus, stderr = getClient(url, username, password)\r\n        \r\n        if not sseStatus:\r\n            time.sleep(30)\r\n            client, sseStatus, stderr = getClient(url, username, password)    \r\n            \r\n        if sseStatus:    \r\n            jobData, stderr, resultList, flg, job_data_ready_flg = getJobData(job_id, client, operation, targets, action)\r\n            \r\n            success = True\r\n        else:\r\n            for eachserver in targets:\r\n                server = {}\r\n                server['server_name'] = eachserver\r\n                server['status'] = 'failed'\r\n                server['reason']  = 'Not able to get jobout for this id due to Salt issue function' + str(stderr) + str(job_id) + 'for operation ' + operation\r\n                serverStatus.append(server)\r\n            success = False\r\n\r\n    except Exception as e:\r\n        stderr = str(e)\r\n        for eachserver in targets:\r\n            server = {}\r\n            server['server_name'] = eachserver\r\n            server['status'] = 'failed'\r\n            server['reason']  = 'Not able to get jobout for this id due to Salt issue function' + str(stderr) + str(job_id) + 'for operation ' + operation\r\n            serverStatus.append(server)\r\n    if success:\r\n        overallStatus = 'successful'\r\n    else:\r\n        overallStatus = 'failed'\r\n        \r\n\r\n    return {\r\n        \"job_data\": jobData,\r\n        \"success\": str(success),\r\n        \"stderr\" : str(stderr) + str(jobData),\r\n        \"results\" : jobData,\r\n        \"raw_results\" : json.dumps(jobData),\r\n        \"servers_status\" : json.dumps(serverStatus),\r\n        \"result_list\" : resultList,\r\n        \"pre_dnh_exe_flg\" : flg,\r\n        \"overall_status\" : overallStatus,\r\n        \"job_data_ready_flg\" : job_data_ready_flg\r\n    }        \r\n\r\ndef parseWindowsPreToInstallJobData(job_data, hostnames, action):\r\n    serverStatus1 = []\r\n    serverCount = 0\r\n\r\n    if job_data:\r\n        serverCount = len(job_data)\r\n\r\n    for id in range(0, serverCount):\r\n        minion = job_data[id]['full_ret']['id']\r\n        status = job_data[id]['full_ret'].get('retcode')\r\n        errorMsg = ''\r\n        try:\r\n            if isinstance(job_data[id].get('return'), dict):\r\n                output = job_data[id].get('return').get(action).get('changes').get('stdout').strip()\r\n            else:\r\n                output = ''\r\n                serverStatus1.append(minion)\r\n        except Exception as e:\r\n            output = []\r\n            errorMsg = str(e)\r\n\r\n        if output:\r\n            if '\"' in output:\r\n                output = output.replace('\"', '')\r\n                output = output.replace('\\r\\n', '')\r\n                output = output.replace('\\n', '')\r\n                output = output.replace('\\\\', '')\r\n\r\n            try:\r\n                out = re.search(\"error_message(.+?)\\w\", output).group(1)\r\n                if out:\r\n                    if \"''\" in out:\r\n                        output = output.replace(\"'error_message':''\", \"'error_message':'\")\r\n                        output = output.replace(\"''}\", \"'}\")\r\n            except Exception as e:\r\n                pass\r\n            \r\n            try:\r\n                output = output.replace(\"'\", '\"')\r\n                output = json.loads(output)\r\n                if output.keys():\r\n                    #if output.get('Pre-DNH_Fail') or (output.get('is_reboot_needed') or output.get('is_reb\\r\\noot_needed')):\r\n                    serverStatus1.append(minion)\r\n            except:\r\n                if 'is_reboot_needed' in output:\r\n                    serverStatus1.append(minion)\r\n                    \r\n    return serverStatus1\r\n    \r\ndef parseWindowsPreCheckJobData(job_data, hostnames, action):\r\n    serverStatus1 = []\r\n    serverCount = 0\r\n\r\n    if job_data:\r\n        serverCount = len(job_data)\r\n\r\n    for id in range(0, serverCount):\r\n        minion = job_data[id]['full_ret']['id']\r\n        status = job_data[id]['full_ret'].get('retcode')\r\n        errorMsg = ''\r\n        try:\r\n            if isinstance(job_data[id].get('return'), dict):\r\n                output = job_data[id].get('return').get('stdout').strip()\r\n            else:\r\n                output = ''\r\n                serverStatus1.append(minion)\r\n        except Exception as e:\r\n            output = []\r\n            errorMsg = str(e)\r\n\r\n        if output:\r\n            serverStatus1.append(minion)                    \r\n    return serverStatus1\r\n    \r\n\r\ndef parseWindowsFinalPostInstallJobData(job_data, hostnames, action):\r\n    serverStatus = []\r\n    serverCount = 0\r\n    if job_data:\r\n        serverCount = len(job_data)\r\n    #import pdb;pdb.set_trace()\r\n    for id in range(0, serverCount):\r\n        minion = job_data[id]['full_ret']['id']\r\n        status = job_data[id]['full_ret'].get('retcode')\r\n        errorMsg = ''\r\n        \r\n        try:\r\n            if isinstance(job_data[id].get('return'), dict):\r\n                if 'retry' in action:\r\n                    jobDataKeys = job_data[id].get('return').keys()\r\n                    for each in jobDataKeys:\r\n                        if 'retry' in each:\r\n                            action = each\r\n                            break\r\n                output = job_data[id].get('return').get(action).get('changes').get('stdout').strip()\r\n            else:\r\n                output = ''\r\n                serverStatus.append(minion)\r\n        except Exception as e:\r\n            output = []\r\n                \r\n        if output:\r\n            if '\"' in output:\r\n                output = output.replace('\"', '')\r\n                output = output.replace('\\r\\n', '')\r\n                output = output.replace('\\n', '')\r\n                output = output.replace('\\\\', '')\r\n\r\n            try:\r\n                out = re.search(\"error_message(.+?)\\w\", output).group(1)\r\n                if out:\r\n                    if \"''\" in out:\r\n                        output = output.replace(\"'error_message':''\", \"'error_message':'\")\r\n                        output = output.replace(\"''}\", \"'}\")\r\n            except Exception as e:\r\n                pass\r\n\r\n        if output:\r\n            try:\r\n                output = output.replace(\"'\", '\"')\r\n                output = json.loads(output)\r\n                if output.keys():\r\n                    serverStatus.append(minion)\r\n            except:\r\n                if 'is_reboot_needed' in output:\r\n                    serverStatus.append(minion)\r\n                    \r\n    return serverStatus\r\n\r\ndef getJobData(jid, client, operation, targets, action):\r\n    job_data_ready_flg = False\r\n    retData = []\r\n    originalData = []\r\n    resultList = []\r\n    stderr = None\r\n    pre_dnh_exe_flg = 0\r\n    if jid is None:\r\n        return None\r\n    \r\n    resultList = []\r\n    try:\r\n        jobData = client.api.ret.get_returns(jid=str(jid), limit=200)\r\n        retData = jobData.ret['results']\r\n        if retData:\r\n            originalData = retData\r\n            retData[0]['low'] = ''\r\n            if operation == 'True':\r\n                try:\r\n                    if 'windows_Pre_To_Install' in action:    \r\n                        resultList = parseWindowsPreToInstallJobData(retData, targets, action)\r\n                        pre_dnh_exe_flg = 1\r\n                    elif 'Pre-Check_for_24Hours_Ahead' in action:\r\n                        resultList = parseWindowsPreCheckJobData(retData, targets, action)\r\n                    elif 'Windows_Post_Patch_Signature' in action:\r\n                        resultList = parseWindowsPreCheckJobData(retData, targets, action)    \r\n                    else:\r\n                        resultList = parseWindowsFinalPostInstallJobData(retData, targets, action)                        \r\n                except Exception as e:\r\n                    stderr = str(e)\r\n                    resultList = []\r\n                \r\n    except Exception as e:\r\n        retData = []\r\n        stderr = str(e)\r\n        stderr = 'Failed to execute remote command ' +  str(stderr)\r\n\r\n    if retData == []:\r\n        job_data_ready_flg = False\r\n        \r\n    if resultList:\r\n        if len(resultList) == len(targets):    \r\n            job_data_ready_flg = True\r\n        else:\r\n            job_data_ready_flg = False\r\n    return retData, stderr, resultList, pre_dnh_exe_flg, job_data_ready_flg\r\n\r\n    \r\ndef getClient(url, username, password):\r\n    client = None\r\n    reason = None\r\n    try:\r\n        client = SyncClient.connect(url, username, password,\r\n                                rpc_api_version='2', force_restfull=True,\r\n                                ssl_validate_cert=False, connect_timeout=180, request_timeout=180)\r\n        sseStatus = True                        \r\n    except Exception as e:\r\n        reason = str(e)\r\n        reason = 'Failed to connect salt master ' + url + str(reason)\r\n        sseStatus = False\r\n    \r\n    return client, sseStatus, reason"
  results:
    - SUCCESS
